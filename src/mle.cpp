#include "sparse_learning.h"

/* (Task 1) If reaction types are known, then the task of the
 * code ./mle is to learn the rate constants of reactions. 
 * In this case, each (non-repeated) reaction corresponds to one basis function.  
 *
 * The correspondence between reactions and basis functions are as follows:
 *
 *    Reaction    |   Basis
 * 1. A  -> *     |    x
 * 2. A+B -> *    |    x*y
 * 3. 2A -> *     |    x(x-1)
 *
 * In the above, A, B are two different species, and x, y are their copy-numbers.
 *
 */

/* 
 *
 * Determine channel information of each reaction from trajectory data.
 *
 *  This function is similar to the function:
 *
 *   	void find_channels_in_traj(vector<vector<vector<int> > > & traj_data)
 *
 *  in the file prepare.cpp. 
 *
 *  Different from that one in the file prepare.cpp, here: 
 *
 *  	1. both the list and the number of channel vectors are read from the file generated by ./prepare 
 *  	2. trajectories are distributed among processors
 *
 */

void determine_channel_index_of_each_reaction_in_traj(vector<vector<vector<int> > > & traj_data)
{
  map<vector<int>, int> channel_to_idx ;
  vector<int> vec_change ;
  int idx ;

  vec_change.resize(n) ;
  channel_idx_in_traj.resize(local_N_traj) ;
  Mi_in_traj.resize(local_N_traj) ;

  // channel_list is loaded from file, which is generated by running ./prepare
  for (int i = 0 ; i < channel_num ; i ++)
    channel_to_idx[ channel_list[i] ] = i ;

  // loop for each trajectory
  for (int traj_idx = 0 ; traj_idx < local_N_traj ; traj_idx ++)
  {
    channel_idx_in_traj[traj_idx].resize( num_state_in_traj[traj_idx] - 1 ) ;
    Mi_in_traj[traj_idx].resize(channel_num, 0) ;

    // for each reaction in the trajectory
    for (int i = 0; i < num_state_in_traj[traj_idx]-1; i ++)
    {
      // change vector
      for (int j = 0; j < n ; j ++)
	vec_change[j] = traj_data[traj_idx][i+1][j] - traj_data[traj_idx][i][j] ;

      if (channel_to_idx.count(vec_change) == 1)
      {
	idx = channel_to_idx[vec_change] ;
	channel_idx_in_traj[traj_idx][i] = idx ;
	// subtract by 1, because channel index starts from one   
	Mi_in_traj[traj_idx][idx] ++ ;
      } else // something wrong...
      {
	printf("Error: reaction doesn't belong to any channels\n") ; 
	printf("\tchange vector: ");
	for (int ii = 0 ; ii < n ; ii++)
	{
	  printf( "%d ", vec_change[ii] );
	}
	printf("\n") ;
	exit(1) ;
      }
    }
  }

  int * l_mi_traj, * mi_traj_vec ;

  l_mi_traj = (int *) malloc( sizeof(int) * channel_num ) ;
  mi_traj_vec = (int *) malloc( sizeof(int) * channel_num ) ;

  for (int i = 0 ; i < channel_num; i ++)
    l_mi_traj[i] = 0 ;

  for (int i = 0 ; i < channel_num; i ++)
    for (int traj_idx = 0 ; traj_idx < local_N_traj ; traj_idx ++)
      l_mi_traj[i] += Mi_in_traj[traj_idx][i] ;

#if USE_MPI == 1
  MPI_Allreduce(l_mi_traj, mi_traj_vec, channel_num, MPI_INT, MPI_SUM, MPI_COMM_WORLD) ;
#else
  for (int i = 0 ; i < channel_num; i ++)
    mi_traj_vec[i] = l_mi_traj[i] ;
#endif

  Mi_in_all_traj.resize(channel_num) ;
  for (int i = 0 ; i < channel_num; i ++)
    Mi_in_all_traj[i] = mi_traj_vec[i] ;

  free(l_mi_traj) ;
  free(mi_traj_vec) ;
}

/*
 * Read trajectory data from file.
 * Each processor reads part of the whole data.
 *
 */
void read_trajectory_data() 
{
  char buf[100] ;
  ifstream in_file ;
  double t_now , tau , previous_tau , local_T ;
  int channel_idx ;
  string line ;
  vector<int> c_state ;

  num_state_in_traj.resize(local_N_traj) ;
  traj_vec.resize(local_N_traj) ;
  waiting_time_vec.resize(local_N_traj) ;
  t_vec.resize(local_N_traj) ;
  T_traj_vec.resize(local_N_traj) ;
  local_T = 0 ;

  // each process loads part of the trajectory data that it will process
  for ( int j = 0 ; j < local_N_traj ; j ++ )
    {
      sprintf( buf, "./traj_data/traj_%d.txt", j + local_traj_start_idx ) ;
      in_file.open(buf) ;
      if ( ! in_file.is_open() )
      {
	printf("Error: can not open file : %s, trajectory data is incomplete! \n\n", buf) ;
	exit(1) ;
      }

      in_file >> n ;
      c_state.resize(n) ;

      num_state_in_traj[j] = 0 ;
      // read line by line
      while ( getline(in_file, line) )
      {
	if (line.find_first_not_of(' ') != string::npos) 
	{
	  istringstream iss(line) ;
	  iss >> t_now ;
	  for (int i = 0 ; i < n ; i ++)
	    iss >> c_state[i] ;
	  iss >> tau ;

	  traj_vec[j].push_back(c_state) ;
	  t_vec[j].push_back(t_now) ;
	  waiting_time_vec[j].push_back(tau) ;

	  num_state_in_traj[j] ++ ;
	}
      }

      // the length of the current trajectory 
      T_traj_vec[j] = t_vec[j][num_state_in_traj[j] - 1] + waiting_time_vec[j][num_state_in_traj[j] - 1] ;
      // the total length of trajectories on the local processor
      local_T += T_traj_vec[j] ;

      in_file.close() ;
    }

  // compute the total length of all trajectories 
#if USE_MPI == 1
  MPI_Allreduce( &local_T, &total_T, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD ) ;
#else
  total_T = local_T ;
#endif
}

/*
 * Simple gradient descent method (with fixed step size) to solve the smooth optimization problem (of the negative likelihood function)
 */
void grad_descent_smooth() 
{
  double residual, tmp ;
  int iter_step , stop_flag , prev_min_step ; 
  vector<vector<double> > omega_grad_vec ;
  ofstream out_file ;
  char buf[100] ;

  vector<vector<double> > vec_tmp ;
  double fval_new, prev_cost ;

  double tail_cost_max, tail_cost_min ;
  double min_ai, max_ai ;

  omega_grad_vec.resize( channel_num ) ;
  vec_tmp.resize( channel_num ) ;
  min_cost.resize( channel_num ) ;
  optimal_omega_vec.resize( channel_num ) ;

  for (int i = 0; i < channel_num; i ++)
  {
    vec_tmp[i].resize( basis_index_per_channel[i].size() ) ;
    omega_grad_vec[i].resize( basis_index_per_channel[i].size() ) ;
    optimal_omega_vec[i].resize( basis_index_per_channel[i].size() ) ;
  }

  /* 
   *
   * The log-likelihood function ln L(w) can be written as 
   * 	ln L(w) = \sum_{i=1}^K ln L_i(w_i), 
   * i.e., unknown parameters belonging to different reaction channels are decoupled.
   *
   * Therefore, we solve the unknown coefficients for each channel separately (only for those required).
   *
   */
  for (int i =0 ; i < channel_num; i ++)
  {
    if (mpi_rank == 0)
    {
      printf("Solving coefficients for the reaction channel %d...\n", i) ;
      fprintf(log_file, "Solving coefficients for the reaction channel %d...\n", i) ;

      sprintf( buf, "./output/iteration_omega_vec_for_channel_%d.txt", i) ;

      out_file.open(buf) ;
      if ( out_file.is_open() == 0 ) 
	{
	  printf("Error: can not open file : %s. \n\n", buf) ;
	  fprintf(log_file, "Error: can not open file : %s. \n\n", buf) ;
	  exit(1) ;
	}
      // number of unknown coefficients in the current channel
      out_file << basis_index_per_channel[i].size() << endl ;
    }

    // initialize 
    iter_step = 0 ;
    min_cost[i] = 1e8 ;
    prev_cost = 1e8 ;
    stop_flag = 0 ;

    // costs of previous steps are recorded in these two stacks
    tail_cost_vec_1.resize(0);
    tail_cost_vec_2.resize(0);

    // update the parameters iteratively
    while ( iter_step < tot_step ) 
    {
      residual = 0.0 ;

      // compute the gradient of the log-likelihood functions
      grad_minus_log_likelihood_partial(i, omega_vec, omega_grad_vec) ;

      // update the vector by gradient descent
      for (int j = 0 ; j < basis_index_per_channel[i].size() ; j ++)
      {
	tmp = omega_vec[i][j] ;
	vec_tmp[i][j] = omega_vec[i][j] - grad_dt * omega_grad_vec[i][j] ;
      }

      // compute residual
      residual = rel_error_of_two_vectors(omega_vec[i], vec_tmp[i]) ;

      // update x_k
      for (int j = 0 ; j < basis_index_per_channel[i].size() ; j ++)
	omega_vec[i][j] = vec_tmp[i][j] ;

      fval_new = minus_log_likelihood_partial(i, omega_vec, min_ai, max_ai ) ; 

      if ( (iter_step == 0) || (fval_new < min_cost[i]) )
      {
	min_cost[i] = fval_new ;

	for (int j = 0 ; j < basis_index_per_channel[i].size() ; j ++)
	  optimal_omega_vec[i][j] = omega_vec[i][j] ;

	prev_min_step = iter_step ;
      }

      /* 
       * Check if stop criteria is achieved, based on: 
       *
       * 1. if the (previous) minimal cost hasn't been updated after many steps 
       *     	(in this case, stop_flag = 1)
       *
       * 2. if the relative error between the min and max of the costs in the previous steps is smaller 
       *    than certain threshold (in this case, stop_flag = 2)
       *
       */
      if (iter_step - prev_min_step > max_step_since_prev_min_cost)
      {
	stop_flag = 1 ;
	break ;
      }

      update_tail_cost_vec(iter_step, fval_new , tail_cost_min, tail_cost_max) ;
      if ( (iter_step >= num_record_tail_cost) && (rel_error(tail_cost_max, tail_cost_min) < cost_stop_tol) )
      {
	stop_flag = 2 ;
	break ;
      }

      iter_step ++ ;
      if (iter_step % output_interval == 0) // print information 
      {
	if (mpi_rank == 0)
	{
	  printf( "Iteration step = %d\n\tminus-likelihood = %.8e\n", iter_step, fval_new ) ;
	  printf( "\tRel. residual of vec. = %.6e \n\tRel. diff. of cost = %.6e \n\tRel. diff. of cost (w.r.t. optimal) = %.6e\n", residual, rel_error(fval_new , prev_cost),  rel_error(fval_new , min_cost[i]) ) ;
	  printf("\tCosts in the last %d steps: [%.6e, %.6e],\tRel-diff. = %.4e (%.2e)\n", min(iter_step, num_record_tail_cost), tail_cost_min, tail_cost_max, rel_error(tail_cost_max, tail_cost_min), cost_stop_tol) ;

	  fprintf( log_file, "Iteration step = %d\n\tminus-likelihood = %.8e\n", iter_step, fval_new ) ;
	  fprintf( log_file, "\tRel. residual of vec. = %.6e \n\tRel. diff. of cost = %.6e \n\tRel. diff. of cost (w.r.t. optimal) = %.6e\n", residual, rel_error(fval_new , prev_cost),  
	      rel_error(fval_new , min_cost[i]) ) ;
	  fprintf( log_file, "\tCosts in the last %d steps: [%.6e, %.6e],\tRel-diff. = %.4e (%.2e)\n", min(iter_step, num_record_tail_cost), tail_cost_min, tail_cost_max, rel_error(tail_cost_max, tail_cost_min), cost_stop_tol) ;

	  print_omega_coefficients(i, omega_vec) ;

	  out_file << iter_step << "\t" << std::setprecision(8) ;

	  for (int j = 0 ; j < basis_index_per_channel[i].size() ; j ++)
	    out_file << omega_vec[i][j] << ' ' ;

	  out_file << "\t" << std::setprecision(8) << fval_new + tmp << "\t" << residual << endl ;

	  printf("\trange of ai=[%.2e,%.2e]\n", min_ai, max_ai ) ;
	  fprintf( log_file, "\trange of ai=[%.2e,%.2e]\n", min_ai, max_ai ) ;
	}
      }
      prev_cost = fval_new ;
    }

    if (mpi_rank == 0)
    {
      out_file.close() ;

      printf("\n========================================================\n") ;
      fprintf(log_file, "\n========================================================\n") ;

      printf("Solving coefficients for the reaction channel %d... finished.\n\n\tReason of termination:\t", i);
      fprintf(log_file, "Solving coefficients for the reaction channel %d... finished.\n\n\tReason of termination:\t", i);

      // print the reason of termination 
      switch (stop_flag) {
	case 0 : 
	  printf("Maximal steps (%d) achieved.\n", tot_step);
	  fprintf(log_file, "Maximal steps (%d) achieved.\n", tot_step);
	  break ;
	case 1 :
	  printf("Minimal cost hasn't been updated after %d steps.\n", max_step_since_prev_min_cost) ;
	  fprintf(log_file, "Minimal cost hasn't been updated after %d steps.\n", max_step_since_prev_min_cost) ;
	  break ;
	case 2 :
	  printf("Changes of the costs in the last %d steps are under threshold.\n", num_record_tail_cost) ;
	  fprintf(log_file, "Changes of the costs in the last %d steps are under threshold.\n", num_record_tail_cost) ;
	  break ;
      }

      printf( "\n\tTotal steps=%d,\t Final cost = %.8e,\t min_cost=%.8e (at Step %d)\n\n", iter_step, prev_cost, min_cost[i], prev_min_step ) ;
      printf( "\tRel. residual of vec. = %.6e \n\tRel. diff. of cost = %.6e\n\tRel. diff. of cost (w.r.t. optimal) = %.6e\n", residual, rel_error(fval_new , prev_cost),  rel_error(fval_new, min_cost[i]) ) ;
      printf("\tCosts in the last %d steps: [%.6e, %.6e],\tRel-diff. = %.4e (%.2e)\n", min(iter_step, num_record_tail_cost), tail_cost_min, tail_cost_max, rel_error(tail_cost_max, tail_cost_min), cost_stop_tol) ;

      fprintf( log_file, "\n\tTotal steps=%d,\t Final cost = %.8e,\t min_cost=%.8e (at Step %d)\n\n", iter_step, prev_cost, min_cost[i], prev_min_step ) ;
      fprintf( log_file, "\tRel. residual of vec. = %.6e \n\tRel. diff. of cost = %.6e\n\tRel. diff. of cost (w.r.t. optimal) = %.6e\n", residual, rel_error(fval_new , prev_cost),  rel_error(fval_new , min_cost[i]) ) ;
      fprintf( log_file, "\tCosts in the last %d steps: [%.6e, %.6e],\tRel-diff. = %.4e (%.2e)\n", min(iter_step, num_record_tail_cost), tail_cost_min, tail_cost_max, rel_error(tail_cost_max, tail_cost_min), cost_stop_tol) ;

      // the coefficients having smallest cost will be taken as final result. 
      omega_vec[i] = optimal_omega_vec[i] ;

      sprintf( buf, "./output/omega_vec_for_channel_%d.txt", i) ;
      out_file.open(buf) ;
      if ( out_file.is_open() == 0 ) 
	{
	  printf("Error: can not open file : %s. \n\n", buf) ;
	  fprintf(log_file, "Error: can not open file : %s. \n\n", buf) ;
	  exit(1) ;
	}
      // number of unknown coefficients in the current channel
      out_file << basis_index_per_channel[i].size() << endl ;

      for (int j = 0 ; j < omega_vec[i].size(); j ++)
	out_file << std::setprecision(8) << omega_vec[i][j] << ' ';
      out_file << endl ;

      out_file.close() ;

      printf("\n\tResults are written to: %s\n", buf) ;
      fprintf(log_file, "\n\tResults are written to: %s\n", buf) ;


      printf( "\tCorresponding cost : %.6e\n", min_cost[i] ) ;
      fprintf( log_file, "\tCorresponding cost : %.6e\n", min_cost[i] ) ;

      print_omega_coefficients(i, omega_vec) ;

      printf("========================================================\n\n") ;
      fprintf(log_file, "========================================================\n\n") ;
    }
  }

  tmp = 0 ;
  for (int i = 0 ; i < channel_num ; i ++)
    tmp += minus_log_likelihood_partial( i, omega_vec, min_ai, max_ai ) ;

  if (mpi_rank == 0) 
  {
    printf( "Final cost of all channels = %.6f\n\n", tmp ) ;
    fprintf( log_file, "Final cost of all channels = %.6f\n\n", tmp ) ;
  }
}

/*
 *
 * Directly estimation of the rate constants for reaction channels which contain
 * only one reaction.
 *
 * When certain reaction channel only contains 1 reaction, then its unknown 
 * rate constant can be estimated directly by counting.  
 *
 * The results can used to compare with those obtained from iterative methods.
 *
 */
void direct_compute_channel_with_single_reaction() 
{
  int idx;
  double local_s, s ;

  if (mpi_rank == 0) 
    {
      printf("\n========================================================\n") ;
      fprintf(log_file, "\n========================================================\n") ;

      printf("Direct calculation of rates of the following channels (which contains one reaction):\n") ;
      fprintf(log_file, "Direct calculation of rates of the following channels (which contains one reaction):\n") ;
    }

  for ( int i = 0 ; i < channel_num ; i ++ )
    if (basis_index_per_channel[i].size()==1)
    {
      idx = basis_index_per_channel[i][0] ;
      local_s = 0 ;
      for (int traj_idx = 0 ; traj_idx < local_N_traj ; traj_idx ++)
	for (int j = 0; j < num_state_in_traj[traj_idx] ; j ++)
	  local_s += waiting_time_vec[traj_idx][j] * val_basis_funct(idx, traj_vec[traj_idx][j]) ;

#if USE_MPI == 1
      MPI_Allreduce( &local_s, &s, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD ) ;
#else
      s = local_s ;
#endif

      if (mpi_rank == 0) 
      {
	printf("\tRate of channel %d: %.8f\n", i, Mi_in_all_traj[i] * 1.0 / s) ;
	fprintf(log_file, "\tRate of channel %d: %.8f\n", i, Mi_in_all_traj[i] * 1.0 / s) ;
      }
    }
  if (mpi_rank == 0)
  {
    printf("========================================================\n") ;
    fprintf(log_file, "========================================================\n") ;
  }
}

void prepare_channels_info_from_reactions() 
{
  map<vector<int>, int> channel_to_idx ;
  set<vector<int> > channel_vec_set ;

  // find all non-repeated change vectors by looping each reaction
  for (int i = 0 ; i < R ; i ++)
    if ( channel_vec_set.count(vvec[i]) == 0 ) channel_vec_set.insert( vvec[i] ) ;

  // channel index starts from 0
  // create list of channels 
  channel_num = 0 ;
  for (set<vector<int> >::iterator it = channel_vec_set.begin() ; it != channel_vec_set.end() ; it ++)
    {
      channel_to_idx[*it] = channel_num ;
      channel_list.push_back(*it) ;
      channel_num ++ ;
    }

  reactions_in_channel.resize(channel_num) ;
  int idx ;
  for (int i = 0; i < R; i ++)
    {
      // determine channel index of reaction i
      idx = channel_to_idx[vvec[i]] ;
      // add to reaction list of the channel 
      reactions_in_channel[idx].push_back(i) ;
    }
}

void prepare_basis_functions() 
{
  /*
   * Record vectors of (non-repeated) reactants among the R reactions
   */
  map<vector<int>, int> vvec_in_map ;

  /* 
   * Records the index of basis function for each of R reactions.
   */
  vector<int> basis_idx_of_reactions ;

  vector<int> reactant_idx ;

  basis_vec.resize(0) ;
  basis_idx_of_reactions.resize(R) ;

    // We use the propensity functions of R reactions (excluding the repeated ones) as basis functions
  for (int i = 0; i < R; i ++)
      // if the same vector of reactants has not be recorded
    if ( vvec_in_map.count(vvec_in[i]) == 0 ) 
	{
	  reactant_idx.resize(0) ;
	  for (int j = 0; j < n; j ++)
	    for (int j1 = 0; j1 < vvec_in[i][j] ; j1 ++)
	      reactant_idx.push_back(j) ;
	    
	  // add this new basis 
	  basis_vec.push_back( reactant_idx ) ;

	  // record its index
	  vvec_in_map[ vvec_in[i] ] = basis_vec.size() - 1 ;
	  basis_idx_of_reactions[i] = basis_vec.size() - 1 ;
	}
      else // if the same basis has already occured
	basis_idx_of_reactions[i] = vvec_in_map[ vvec_in[i] ] ;

  num_basis = vvec_in_map.size() ; 

  omega_vec.resize( channel_num ) ;
  basis_index_per_channel.resize( channel_num ) ;
  omega_basis_rescale_cst.resize( channel_num ) ;

  int itmp, ridx ;

  for ( int i = 0 ; i < channel_num ; i ++ )
  {
    itmp =  reactions_in_channel[i].size() ; 

    basis_index_per_channel[i].resize( itmp ) ;
    // indices of basis functions for channel i
    for ( int j = 0 ; j < itmp ; j ++ )
    {
	ridx = reactions_in_channel[i][j] ;
	basis_index_per_channel[i][j] = basis_idx_of_reactions[ridx] ;
    }

    omega_vec[i].resize(itmp, 1.0) ;
    omega_basis_rescale_cst[i].resize(itmp, 1.0) ;
  }
}

int main ( int argc, char * argv[] ) 
{

#if USE_MPI == 1
  MPI_Init(&argc, &argv) ;
#endif

  char buf[50] ;

  clock_t start , end ;

  start = clock() ;

  know_reactions_flag=1 ;
  xx_basis_flag == 0 ;

  sprintf(buf, "./log/mle.log") ;
  if ( init(buf) < 0 ) return -1 ;

  read_trajectory_data() ;

  prepare_channels_info_from_reactions() ;

  prepare_basis_functions() ;

  determine_channel_index_of_each_reaction_in_traj(traj_vec) ;

  if ( mpi_rank == 0 )
  {
    printf("\n========================================================\n") ;
    fprintf(log_file, "\n========================================================\n") ;
  }

  if (mpi_rank == 0)
  {
    printf("\nIn total:  %d reaction channels\n\n", channel_num) ;
    fprintf(log_file, "\nIn total:  %d reaction channels\n\n", channel_num) ;

    for (int i =0 ; i < channel_num ; i ++)
    {
      printf("Channel %d: \tChange vector : (", i+1) ; 
      fprintf(log_file, "Channel %d: \tChange vector : (", i+1) ; 
      for (int j = 0 ; j < n ; j ++)
      {
	printf("%d", channel_list[i][j]) ;
	fprintf( log_file, "%d", channel_list[i][j] );
	if (j < n-1) {
	  printf(",");
	  fprintf(log_file, ",");
	} else 
	{
	  printf("),\t\t");
	  fprintf(log_file, "),\t\t");
	}
      }
      printf("Occurrence : %d\n", Mi_in_all_traj[i]) ;
      fprintf(log_file, "Occurrence : %d\n", Mi_in_all_traj[i]) ;
    }

    printf( "\nTotal length of time of %d trajectories : %.6f\n", N_traj, total_T ) ;
    fprintf( log_file, "\nTotal length of time of %d trajectories : %.6f\n", N_traj, total_T ) ;

    printf("========================================================\n\n") ;
    fprintf(log_file, "========================================================\n\n") ;
  }

  if ( is_zero(cost_stop_tol) ) cost_stop_tol = 1e-4;
  if ( is_nonpositive(num_record_tail_cost) ) num_record_tail_cost = 5 ;
  if ( is_nonpositive(max_step_since_prev_min_cost) ) max_step_since_prev_min_cost = 1000 ;

  grad_descent_smooth() ;

  // when reaction types are known and a channel has only one reaction, then
  // the parameter can be computed directly
  direct_compute_channel_with_single_reaction() ;

  end = clock() ;

  if (mpi_rank == 0)
  {
    printf("\n\nRuntime : %4.2f sec.\n\n", (end - start) * 1.0 / CLOCKS_PER_SEC ) ;
    fprintf(log_file, "\n\nRuntime : %4.2f sec.\n\n", (end - start) * 1.0 / CLOCKS_PER_SEC ) ;
    fclose(log_file) ;
  }

#if USE_MPI == 1
  MPI_Finalize() ; 
#endif

  return 0; 
}
