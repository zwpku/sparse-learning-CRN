#include "sparse_learning.h"

double val_ai(int channel_idx, vector<int> &state, vector<vector<double> > & coeff_vec );

/*
 *
 * Process trajectory data under directory ./traj_data, which were generated by
 * ./ssa using SSA method.
 *
 * traj_vec : 		vector containing all trajectories  
 * t_vec : 		vector of time for each state in each trajectory
 * waiting_time_vec : 	vector of waiting time for each reaction in each trajectory 
 * num_state_in_traj :	number of total states in each trajectory 
 *
 */
void process_data() 
{
  char buf[100] ;
  ifstream in_file ;
  double t_now , tau , previous_tau ;
  int itmp ;
  string line ;
  vector<int> c_state ;

  num_state_in_traj.resize(N_traj) ;
  traj_vec.resize(N_traj) ;
  waiting_time_vec.resize(N_traj) ;
  t_vec.resize(N_traj) ;

  printf("Number of trajectories = %d\n\n", N_traj) ;
  fprintf(log_file , "Number of trajectories = %d\n\n", N_traj) ;

  tot_num_reaction_in_traj = 0 ;

  // read trajectory data from file 
  for (int traj_idx = 0 ; traj_idx < N_traj ; traj_idx ++)
  {
    sprintf( buf, "./traj_data/traj_%d.txt", traj_idx ) ;

    fprintf(log_file, "processing %dth trajectory...\n", traj_idx) ;

    in_file.open(buf) ;
    if ( ! in_file.is_open() )
    {
      printf("Error: can not open file : %s, trajectory data is incomplete! \n\n", buf) ;
      fprintf(log_file, "Error: can not open file : %s, trajectory data is incomplete! \n\n", buf) ;
      exit(1) ;
    }

    in_file >> n ;
    c_state.resize(n) ;

    num_state_in_traj[traj_idx] = 0 ;

    // read the file line by line
    while ( getline(in_file, line) )
    {
      if (line.find_first_not_of(' ') != string::npos) 
      {
	istringstream iss(line) ;
	iss >> t_now ;
	for (int i = 0 ; i < n ; i ++)
	  iss >> c_state[i] ;
	iss >> tau ;

	traj_vec[traj_idx].push_back(c_state) ;
	t_vec[traj_idx].push_back(t_now) ;
	waiting_time_vec[traj_idx].push_back(tau) ;

	num_state_in_traj[traj_idx] ++ ;
      }
    }

    tot_num_reaction_in_traj += (num_state_in_traj[traj_idx] - 1) ;
    in_file.close() ;
  }

  sprintf( buf, "./output/channel_info.txt" ) ;
  in_file.open(buf) ;

  in_file >> channel_num >> itmp ;
  in_file.close() ;

  printf("\n\n========================================================\n") ;
  fprintf(log_file, "\n\n========================================================\n") ;

  printf("In total:\n   %d reactions,\t%d reaction channels\n\n", tot_num_reaction_in_traj, channel_num) ;
  fprintf(log_file, "In total:\n   %d reactions,\t%d reaction channels\n\n", tot_num_reaction_in_traj, channel_num) ;
}

/*
 * read the coefficients
 *
 */
void read_omega_coefficients( int i, vector<vector<double> > & coeff_vec )
{
  int itmp ;
  char buf[100];
  ifstream in_file ;
  sprintf( buf, "./output/omega_vec_for_channel_%d.txt", i) ;
  in_file.open(buf) ;
  in_file >> itmp ;
  coeff_vec[i].resize(itmp) ;
  omega_basis_rescale_cst[i].resize(itmp) ;

  for (int j = 0 ; j < itmp ; j ++)
  {
    in_file >> coeff_vec[i][j] ; 
    omega_basis_rescale_cst[i][j] = 1.0 ;
  }
  in_file.close();
}

void read_basis()
{
  int itmp, num_basis ;
  char buf[100];
  ifstream in_file ;

  // read basis functions from file
  sprintf( buf, "./output/basis_funct_info.txt" ) ;
  in_file.open(buf) ;

  in_file >> itmp >> num_basis ;

  // read basis functions
  basis_vec.resize(num_basis) ;
  for (int i = 0 ; i < num_basis ; i ++)
  {
    in_file >> itmp ;
    basis_vec[i].resize(itmp) ;
    for (int j = 0 ; j < itmp ; j ++)
      in_file >> basis_vec[i][j] ;
  }

  in_file.close() ;

  // read basis functions for each channel
  for ( int i = 0 ; i < channel_num ; i ++ )
  {
    sprintf( buf, "./output/basis_of_channel_%d.txt", i ) ;
    in_file.open(buf) ;

    // read number of basis used for channel i
    in_file >> itmp ;
    assert(itmp <= num_basis) ;
    basis_index_per_channel[i].resize(itmp) ;

    // read indices of basis functions for channel i
    for ( int j = 0 ; j < basis_index_per_channel[i].size() ; j ++ )
      in_file >> basis_index_per_channel[i][j] ;

    in_file.close() ;
  } 
}

void find_important_basis_in_traj() 
{
  double tmp , tot_ai ;
  int important_flag , itmp ;

  omega_vec.resize( channel_num ) ;
  omega_basis_rescale_cst.resize( channel_num ) ;

  for (int c_idx = 0 ; c_idx < channel_num ; c_idx ++)
  {
     read_omega_coefficients(c_idx, omega_vec) ;
     for (int j = 0 ; j < num_basis ; j ++)
	  {
	    important_flag = 0;
	    // loop for each trajectory 
	    for (int traj_idx = 0 ; traj_idx < N_traj ; traj_idx ++)
	      for (int i = 0; i < num_state_in_traj[traj_idx] ; i ++) // loop for each jump (or reaction)
	    {
	      // compute the value of basis function at the current state
	      tmp = omega_vec[c_idx][j] * val_basis_funct(j, traj_vec[traj_idx][i]) ;
	      tot_ai = val_ai(c_idx, traj_vec[traj_idx][i], omega_vec);
	      if (fabs(tmp / tot_ai) > 0.1)
		{
		  important_flag = 1;
		  break ;
		}
	    }
	    if (important_flag == 1)
		printf("%dth basis is important for channel %d\n", j, c_idx) ;
	  }
   }
}

int main ( int argc, char * argv[] ) 
{
#if USE_MPI == 1
  MPI_Init(&argc, &argv) ;
#endif

  clock_t start , end ;
  char buf[30]; 

  know_reactions_flag = 0 ;

  sprintf(buf, "./log/important_basis.log") ;
  if (init(buf) < 0) return -1 ;

  // this program can only run sequentially
  assert(mpi_size == 1) ;

  // make sure the directory is ready
  sprintf(buf, "./output") ;
  if (dir_check(buf) != 0) 
    {
      printf ("\nError: directory %s can not be created. Fix the error manually!\n\n", buf) ;
      fprintf (log_file, "\nError: directory %s can not be created. Fix the error manually!\n\n", buf) ;
      exit(1) ;
    }

  start = clock() ;

  process_data() ;

  read_basis() ;

  find_important_basis_in_traj() ;

  end = clock() ;

  printf("\nRuntime : %4.2f sec.\n\n", (end - start) * 1.0 / CLOCKS_PER_SEC ) ;
  fprintf(log_file, "\nRuntime : %4.2f sec.\n\n", (end - start) * 1.0 / CLOCKS_PER_SEC ) ;

  fclose(log_file) ;

#if USE_MPI == 1
  MPI_Finalize() ; 
#endif

  return 0; 
}
